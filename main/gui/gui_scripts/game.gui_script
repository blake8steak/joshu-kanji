local settings = require("main.scripts.settings")
local banks = require("main.scripts.puzzleBanks")
local kanji = require("main.scripts.kanjiBanks")

local puzzleIndex
local score
local seconds
local gameFinished


-- This is just an example bank.
local kanjiPuzzleKeys = {
	"a",
	"b",
	"c",
}

local kanjiPuzzleBank = {
	-- BANK GOES COUNTERCLOCKWISE
	--[[ 
	
		Bank for example puzzle 気

				天病持分
	
				　　天
				病　気　分
				　　持

				天気
				病気
				気持
				気分
	]]--


	
	["a"]="1234",
	["b"]="2345",
	["c"]="3456",
}


local kanjiPuzzleBankLength = 3

function init(self)
	-- Add initialization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
	gameFinished = false
	math.randomseed(socket.gettime()%10000)	
	set_timer()
	seconds = settings.time + 4
	msg.post(".", "acquire_input_focus")
	score = 0
	new_puzzle()
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn1"), action.x, action.y) then
		check_answer(1)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn2"), action.x, action.y) then
		check_answer(2)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn3"), action.x, action.y) then
		check_answer(3)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn4"), action.x, action.y) then
		check_answer(4)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn5"), action.x, action.y) then
		check_answer(5)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("btn6"), action.x, action.y) then
		check_answer(6)
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("againBtn"), action.x, action.y) then
		-- reload collection and play again
		if gameFinished then
			msg.post("main:/main#main", "start_game")
		end
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("exitBtn"), action.x, action.y) then
		-- reload collection and play again
		if gameFinished then
			msg.post("main:/main#main", "start_settings")
		end
	elseif action_id == hash("touch") and action.pressed and gui.pick_node(gui.get_node("quit"), action.x, action.y) then
		msg.post("main:/main#main", "start_settings")
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

function check_answer(num) 
	local correct = kanjiPuzzleKeys[puzzleIndex]
	local answer = gui.get_text(gui.get_node("kanji"..num))
	if correct == answer then
		score = score + 1
		highlight_box(gui.get_node("btn"..num), true)
		highlight_box(gui.get_node("points"), true)
		sound.play("/game#correct", {delay = 0, gain = 0.8, speed = 1})
	else
		if score > 0 then
			score = score - 1
		end
		highlight_box(gui.get_node("btn"..num), false)
		highlight_box(gui.get_node("points"), false)
		sound.play("/game#incorrect", {delay = 0, gain = 0.8, speed = 1})
	end
	gui.set_text(gui.get_node("points"), ""..score)
end

function reset_box(node)
	local white = vmath.vector4(1, 1, 1, 1)
	gui.animate(gui.get_node("btn1"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("btn2"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("btn3"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("btn4"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("btn5"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("btn6"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	gui.animate(gui.get_node("points"), gui.PROP_COLOR, white, gui.EASING_LINEAR, 0.2)
	new_puzzle()
end

function highlight_box(node, correct)
	-- only called to highlight node1 yellow
	local green = vmath.vector4(0.4, 0.9, 0.4, 1)
	local red = vmath.vector4(0.9, 0.4, 0.4, 1)
	if correct then
		gui.animate(node, gui.PROP_COLOR, green, gui.EASING_LINEAR, 0.05, 0, reset_box)
	else
		gui.animate(node, gui.PROP_COLOR, red, gui.EASING_LINEAR, 0.05, 0, reset_box)
	end
end

-- Gets a random index of the current class, or a class below it.
function getRandomIndex()
	if settings.class == "610D" then
		return 1
	elseif settings.class == "611D" then
		return math.random(2)
	elseif settings.class == "317C" then
		return math.random(3)
	elseif settings.class == "320K" then
		return math.random(4)
	elseif settings.class == "320L" then
		return math.random(5)
	end	
end

function new_puzzle()
	local bankIndex = getRandomIndex()
	if bankIndex == 1 then
		kanjiPuzzleBankLength = banks.length610D
		kanjiPuzzleBank = banks.pairs610D
		kanjiPuzzleKeys = banks.keys610D
	elseif bankIndex == 2 then
		kanjiPuzzleBankLength = banks.length611D
		kanjiPuzzleBank = banks.pairs611D
		kanjiPuzzleKeys = banks.keys611D
	elseif bankIndex == 3 then
		kanjiPuzzleBankLength = banks.length317C
		kanjiPuzzleBank = banks.pairs317C
		kanjiPuzzleKeys = banks.keys317C
	elseif bankIndex == 4 then
		kanjiPuzzleBankLength = banks.length320K
		kanjiPuzzleBank = banks.pairs320K
		kanjiPuzzleKeys = banks.keys320K
	elseif bankIndex == 5 then
		kanjiPuzzleBankLength = banks.length320L
		kanjiPuzzleBank = banks.pairs320L
		kanjiPuzzleKeys = banks.keys320L
	end
	puzzleIndex = math.random(1, kanjiPuzzleBankLength)
	set_new_puzzle_chars() 
end

function set_new_puzzle_chars() 
	local puzzleChars = {}

	for c in kanjiPuzzleBank[kanjiPuzzleKeys[puzzleIndex]]:gmatch("[%z\1-\127\194-\244][\128-\191]*") do
		table.insert(puzzleChars, c)
	end
	
	local indexArr = shuffle({1,2})

	gui.set_text(gui.get_node("puzzleKanji1"), puzzleChars[indexArr[1]])
	gui.set_text(gui.get_node("puzzleKanji2"), puzzleChars[indexArr[2]])

	indexArr = shuffle({3,4})
	gui.set_text(gui.get_node("puzzleKanji3"), puzzleChars[indexArr[1]])
	gui.set_text(gui.get_node("puzzleKanji4"), puzzleChars[indexArr[2]])

	indexArr = shuffle({1,2,3,4,5,6})

	local kanjiIndexArr = {puzzleIndex, -2, -3, -4, -5, -6}
	local kanjiRandBankIndex = getRandomIndex()
	
	gui.set_text(gui.get_node("kanji"..indexArr[1]), kanjiPuzzleKeys[puzzleIndex])
	kanjiIndexArr = set_random_kanji(gui.get_node("kanji"..indexArr[2]), kanjiIndexArr, 2, kanjiRandBankIndex, kanjiPuzzleKeys[puzzleIndex])
	kanjiIndexArr = set_random_kanji(gui.get_node("kanji"..indexArr[3]), kanjiIndexArr, 3, kanjiRandBankIndex, kanjiPuzzleKeys[puzzleIndex])
	kanjiIndexArr = set_random_kanji(gui.get_node("kanji"..indexArr[4]), kanjiIndexArr, 4, kanjiRandBankIndex, kanjiPuzzleKeys[puzzleIndex])
	kanjiIndexArr = set_random_kanji(gui.get_node("kanji"..indexArr[5]), kanjiIndexArr, 5, kanjiRandBankIndex, kanjiPuzzleKeys[puzzleIndex])
	kanjiIndexArr = set_random_kanji(gui.get_node("kanji"..indexArr[6]), kanjiIndexArr, 6, kanjiRandBankIndex, kanjiPuzzleKeys[puzzleIndex])
end

function get_unused_kanji(kanjiIndexArr, length, kanjiRandBankIndex, correctKanji, kanjiStr)
	--
	-- technically, this blocks on
	-- a given index across all given banks;
	-- (i.e. if a 10 is generated, index 10
	-- cannot be pulled from on 610D, 611D, 317C,
	-- etc.)
	--
	-- not really a huge issue tho, this is
	-- only just pulling randomly generated kanjis
	-- anyways
	--
	local unusedIndexFound = false
	local num = 1
	while not unusedIndexFound do
		num = math.random(length)

		local innerLoopIndexNotFound = false
		for n=1, 6 do
			if num == kanjiIndexArr[n] then
				innerLoopIndexNotFound = true
				break
			end
		end

		if not innerLoopIndexNotFound then
			local index = 1
			-- jank, but idk how else to get kanji to work properly :P
			for c in kanjiStr:gmatch("[%z\1-\127\194-\244][\128-\191]*") do
				if index == num then
					if c == correctKanji then
						-- duplicate, run again
					else
						return num
					end
				end
				index = index + 1
			end
		end
	end
end

function set_random_kanji(node, kanjiIndexArr, kanjiNum, kanjiIndex, correctKanji)
	local kanjiStr = ""
	local num = 1
	if kanjiIndex == 1 then
		kanjiStr = kanji.kanji610D
		num = get_unused_kanji(kanjiIndexArr, kanji.kanji610DLength, kanjiIndex, correctKanji, kanjiStr)
	elseif kanjiIndex == 2 then
		kanjiStr = kanji.kanji611D
		num = get_unused_kanji(kanjiIndexArr, kanji.kanji611DLength, kanjiIndex, correctKanji, kanjiStr)
	elseif kanjiIndex == 3 then
		kanjiStr = kanji.kanji317C
		num = get_unused_kanji(kanjiIndexArr, kanji.kanji317CLength, kanjiIndex, correctKanji, kanjiStr)
	elseif kanjiIndex == 4 then
		kanjiStr = kanji.kanji320K
		num = get_unused_kanji(kanjiIndexArr, kanji.kanji320KLength, kanjiIndex, correctKanji, kanjiStr)
	elseif kanjiIndex == 5 then
		kanjiStr = kanji.kanji320L
		num = get_unused_kanji(kanjiIndexArr, kanji.kanji320LLength, kanjiIndex, correctKanji, kanjiStr)
	end

	kanjiIndexArr[kanjiNum] = num
	
	local index = 1
	-- jank, but idk how else to get kanji to work properly :P
	for c in kanjiStr:gmatch("[%z\1-\127\194-\244][\128-\191]*") do
		if index == num then
			gui.set_text(node, c)
			return kanjiIndexArr
		end
		index = index + 1
	end
end

function set_timer()
	gui.set_text(gui.get_node("seconds"), "-")
	local timer = timer.delay(1, true, update_timer_label)
end

function update_timer_label()
	local red = vmath.vector4(0.9, 0.1, 0.1, 1)
	local yellow = vmath.vector4(0.9, 0.9, 0.1, 1)
	local green = vmath.vector4(0.1, 0.9, 0.1, 1)
	local black = vmath.vector4(0, 0, 0, 1)
	local white = vmath.vector4(1, 1, 1, 1)
	local whiteAlpha = vmath.vector4(1, 1, 1, 0.98)
	local invisible = vmath.vector4(0, 0, 0, 0)
	
	if seconds == settings.time + 4 then
		sound.play("/game#countdown", {delay = 0, gain = 0.9, speed = 1})
		gui.set_color(gui.get_node("red"), black)
		gui.set_color(gui.get_node("yellow"), black)
		gui.set_color(gui.get_node("green"), black)
		seconds = seconds - 1
	elseif seconds == settings.time + 3 then
		seconds = seconds - 1
		gui.animate(gui.get_node("red"), gui.PROP_COLOR, red, gui.EASING_LINEAR, 0.05)
	elseif seconds == settings.time + 2 then
		seconds = seconds - 1
		gui.animate(gui.get_node("yellow"), gui.PROP_COLOR, yellow, gui.EASING_LINEAR, 0.05, 0, reset_box)
	elseif seconds == settings.time + 1 then
		seconds = seconds - 1
		gui.animate(gui.get_node("green"), gui.PROP_COLOR, green, gui.EASING_LINEAR, 0.05, 0, reset_box)
	elseif seconds == settings.time then
		gui.set_color(gui.get_node("red"), invisible)
		gui.set_color(gui.get_node("yellow"), invisible)
		gui.set_color(gui.get_node("green"), invisible)
		gui.set_color(gui.get_node("hideContent"), invisible)
		sound.play("/game#gameBgm", {delay = 0, gain = 0.5, speed = 1})
		seconds = seconds - 1
		if seconds < 0 then
			gui.set_text(gui.get_node("seconds"), "-")
		else 
			gui.set_text(gui.get_node("seconds"), seconds)
		end
	elseif seconds > 0 then
		seconds = seconds - 1
		gui.set_text(gui.get_node("seconds"), seconds)
	elseif seconds == 0 then
		gameFinished = true 
		sound.stop("/game#gameBgm")
		gui.set_color(gui.get_node("hideContent"), whiteAlpha)
		gui.set_color(gui.get_node("gameOver"), white)
		gui.set_text(gui.get_node("score"), ""..score)
		gui.set_color(gui.get_node("score"), white)
		gui.set_color(gui.get_node("againBtn"), white)
		gui.set_color(gui.get_node("exitBtn"), white)
		print("\n== GAME OVER == \n Score: "..score)
		seconds = seconds - 1
	elseif seconds < 0 then
		gui.set_text(gui.get_node("seconds"), "-")
	end
end

function shuffle(t)
	local tbl = {}
	for i = 1, #t do
		tbl[i] = t[i]
	end
	for i = #tbl, 2, -1 do
		local j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
	return tbl
end